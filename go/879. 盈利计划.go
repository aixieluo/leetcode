// 集团里有 n 名员工，他们可以完成各种各样的工作创造利润。
//
// 第 i 种工作会产生 profit[i] 的利润，它要求 group[i] 名成员共同参与。如果成员参与了其中一项工作，就不能参与另一项工作。
//
// 工作的任何至少产生 minProfit 利润的子集称为 盈利计划 。并且工作的成员总数最多为 n 。
//
// 有多少种计划可以选择？因为答案很大，所以 返回结果模 10^9 + 7 的值。
//
//  
//
// 示例 1：
//
// 输入：n = 5, minProfit = 3, group = [2,2], profit = [2,3]
// 输出：2
// 解释：至少产生 3 的利润，该集团可以完成工作 0 和工作 1 ，或仅完成工作 1 。
// 总的来说，有两种计划。
// 示例 2：
//
// 输入：n = 10, minProfit = 5, group = [2,3,5], profit = [6,7,8]
// 输出：7
// 解释：至少产生 5 的利润，只要完成其中一种工作就行，所以该集团可以完成任何工作。
// 有 7 种可能的计划：(0)，(1)，(2)，(0,1)，(0,2)，(1,2)，以及 (0,1,2) 。
//  
//
// 提示：
//
// 1 <= n <= 100
// 0 <= minProfit <= 100
// 1 <= group.length <= 100
// 1 <= group[i] <= 100
// profit.length == group.length
// 0 <= profit[i] <= 100
//
// 来源：力扣（LeetCode）
// 链接：https://leetcode-cn.com/problems/profitable-schemes

/**
100
100
[24,23,7,4,26,3,7,11,1,7,1,3,5,26,26,1,13,12,2,1,7,4,1,27,13,16,26,18,6,1,1,7,16,1,6,2,5,9,19,28,1,23,2,1,3,4,4,3,22,1,1,3,5,34,2,1,22,16,8,5,3,21,1,8,14,2,1,3,8,12,40,6,4,2,2,14,1,11,9,1,7,1,1,1,6,6,4,1,1,7,8,10,20,2,14,31,1,13,1,9]
[5,2,38,25,4,17,5,1,4,0,0,8,13,0,20,0,28,1,22,7,10,32,6,37,0,11,6,11,23,20,13,13,6,2,36,1,0,9,4,5,6,14,20,1,13,6,33,0,22,1,17,12,10,1,19,13,8,1,0,17,20,9,8,6,2,2,1,4,22,11,3,2,6,0,40,0,0,7,1,0,25,5,12,7,19,4,12,7,4,4,1,15,33,14,2,1,1,61,4,5]
 */

package main

import "fmt"

func main() {
	fmt.Println(profitableSchemes(100, 100, []int{24,23,7,4,26,3,7,11,1,7,1,3,5,26,26,1,13,12,2,1,7,4,1,27,13,16,26,18,6,1,1,7,16,1,6,2,5,9,19,28,1,23,2,1,3,4,4,3,22,1,1,3,5,34,2,1,22,16,8,5,3,21,1,8,14,2,1,3,8,12,40,6,4,2,2,14,1,11,9,1,7,1,1,1,6,6,4,1,1,7,8,10,20,2,14,31,1,13,1,9}, []int{5,2,38,25,4,17,5,1,4,0,0,8,13,0,20,0,28,1,22,7,10,32,6,37,0,11,6,11,23,20,13,13,6,2,36,1,0,9,4,5,6,14,20,1,13,6,33,0,22,1,17,12,10,1,19,13,8,1,0,17,20,9,8,6,2,2,1,4,22,11,3,2,6,0,40,0,0,7,1,0,25,5,12,7,19,4,12,7,4,4,1,15,33,14,2,1,1,61,4,5}))
	fmt.Println(profitableSchemes(1, 5, []int{2, 3, 5}, []int{6, 7, 8}))
	fmt.Println(profitableSchemes(9, 5, []int{2, 3, 5}, []int{6, 7, 8}))
	fmt.Println(profitableSchemes(10, 5, []int{2, 3, 5}, []int{6, 7, 8}))
	// fmt.Println(profitableSchemes(5, 3, []int{2, 2, 2}, []int{1, 1, 2}))
	// fmt.Println(profitableSchemes(5, 4, []int{2, 2, 2}, []int{1, 2, 2}))
	// fmt.Println(profitableSchemes(5, 3, []int{2, 2}, []int{2, 3}))
}

func profitableSchemes(n int, minProfit int, group []int, profit []int) int {
	const mod = 1e9 + 7
	dp := make([][][]int, len(group)+1)
	for k := range dp {
		dp[k] = make([][]int, n+1)
		for k2 :=range dp[k] {
			dp[k][k2] = make([]int, minProfit+1)
		}
	}
	dp[0][0][0] = 1
	for i := 0; i < len(group); i++ {
		for j := 0; j <= n; j++ {
			for k := 0; k<= minProfit; k++ {
				if j < group[i] {
					dp[i+1][j][k] = dp[i][j][k]
				} else {
					k2 := 0
					if k - profit[i] > 0 {
						k2 = k-profit[i]
					}
					dp[i+1][j][k] = dp[i][j][k] + dp[i][j-group[i]][k2] % mod
				}
			}
		}
	}
	sum := 0
	for _,v :=range dp[len(group)] {
		sum = (sum + v[minProfit]) % mod
	}
	return sum
}
